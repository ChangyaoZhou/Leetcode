## 01背包问题
解释原文链接: <https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md>

力扣上没有纯01背包问题，只有其应用。关于背包问题，只需要掌握`01背包`和`完全背包`即可，最多再来一个`多重背包`。  

题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。  

|     | 重量 | 价值 |
| --- | --- | ----- |
| 物品0 | 1 | 15 |
| 物品1 | 3 | 20 |
| 物品2 | 4 | 30 |

这题可以用回溯的方法来暴力求解，但是时间复杂度是O(2^n)。太复杂，所以要用动态规划。  

### 法一：dp数组为二维数组
1. 确定dp数组（dp table）以及下标的含义  
   使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少
    ![image](./IMAGES/01背包问题dp数组.png) 
    e.g.dp[1][2]表示`只考虑物品0和1`，装进一个 只能容纳重量为2的 背包里，最大能获得多少价值。其实就是固定j(固定列)，然后只考虑0-i这几个物品，让i从小迭代到大，具体见递推公式。

2. 确定递推公式  
    dp[i][j]有两个方向推出来：
    1. `不装物品 i`：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i太重了，背包j装不下，所以被背包内的价值依然和前面相同。)
    2. `装物品 i`： 由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值  
    `dp[i][j]` = max(`dp[i - 1][j]`, `dp[i - 1][j - weight[i]] + value[i]`);
3. dp数组如何初始化  
    首先当背包重量为0的时候，能存的最大价值一定是0，所以，第一列是0.  
    有递推关系可以看出，有i-1来的，所以i=0，也要被初始化：因为所有的物品只能装一次，所以，第一行中，在j < weight[0]的时候，值为0(因为装不下物品0)；在j > weight[0]的时候，值为value[0]
    ![image](./IMAGES/01背包问题dp数组初始化.png)
4. 确定遍历顺序  
   这是两维的dp数组，可以先遍历物品数量 或者 先遍历背包重量，是一样的，因为求dp[i][j]的时候，只需要左上角的数据
5. 举例推导dp数组 
   ![image](./IMAGES/01背包问题dp数组举例.png)

代码见 backpack_basic.py

### 法二：dp数组为一维数组 【还没看】
传送门：<https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.md>
其实容易看出来，上述两维的数组，在递推公式中，j在左右两边一直保持不变的，所以没必要用二维。可以用滚动数组。  
1. 确定dp数组（dp table）以及下标的含义  
   dp[j] 表示背包容量为 j 时，所能获得的最大价值
2. 确定递推公式  
    dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）  
    此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值。  
    `dp[j]` = max(`dp[j]`, `dp[j - weight[i]] + value[i]`);
3. dp数组如何初始化
    把dp[0]初始化为0即可，其它的项也可以为0
4. 确定遍历顺序  
    先遍历物品，后遍历背包容量，并且背包容量是`倒序遍历`！！！为了保证 物品i只被放进去一次！！！  
    举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15  
    如果正序遍历   
    dp[1] = dp[1 - weight[0]] + value[0] = 15  
    dp[2] = dp[2 - weight[0]] + value[0] = 30  
    此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。  
    为什么倒序遍历，就可以保证物品只放入一次呢？  
    倒序就是先算dp[2]  
    dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）  
    dp[1] = dp[1 - weight[0]] + value[0] = 15  
    所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。  
5. 举例推导dp数组   