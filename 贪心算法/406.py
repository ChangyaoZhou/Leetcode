def reconstructQueue(people):
    """
    局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性
    全局最优：最后都做完插入操作，整个队列满足题目队列属性
    首先将数据按照身高h从大到小来排序，身高相同的，按照k从小到大来排序，
    优先按身高高的people的k来插入，因为后续插入的身高更小，所以后序插入节点也不会影响前面已经插入的节点
    **** 当身高相同时，要优先插入k值小的，e.g.先插入(5,2), 再插入(5,3)
         这样是为了保证在满足(5,2)后，再插入的(5,3)一定会在(5,2)后面，(5,2)依然满足
         如果先插入的是(5,3),那么后插入的(5,2)会在(5,3)前面，使得(5,3)不再满足
    """
    # sort()函数没有返回值，直接改变people的顺序
    # **** lambda返回的是一个元组：当-x[0](维度h）相同时，再根据x[1]（维度k）从小到大排序
    people.sort(key = lambda x: (-x[0], x[1]))
    queue = []
    for p in people:
        queue.insert(p[1], p)  # 将p放在queue中的p[1]位置上， 使插入p后，p的索引是p[1]
    return queue


# people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
people = [[9,0],[7,0],[1,9],[3,0],[2,7],[5,3],[6,0],[3,4],[6,2],[5,2]]
print(reconstructQueue(people))

